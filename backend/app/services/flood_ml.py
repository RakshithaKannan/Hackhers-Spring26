"""
SafeSphere Flood Risk Scorer — transparent, rule-based system.

WHY NOT ML:
  The previous version trained a GradientBoostingRegressor on 2000 synthetic
  samples generated by the same formula used for scoring. That is circular —
  the model just approximated its own training formula, adding noise but no
  real-world accuracy. It also depended on scikit-learn for no benefit.

HOW THE SCORE IS COMPUTED (total: 0–80):

  Factor 1 — Stream gauge height (0–30 pts)
    Based on NJ USGS flood stage benchmarks:
    < 4 ft  → 0 pts   (normal low flow)
    4–7 ft  → 8 pts   (approaching elevated stage)
    7–10 ft → 18 pts  (elevated, heightened risk)
    10–14ft → 25 pts  (near flood stage)
    ≥ 14 ft → 30 pts  (at or above flood stage)

  Factor 2 — Gauge rising rate (0–20 pts)
    A rapidly rising gauge is the #1 flash flood indicator (NWS standard):
    ≤ 0 ft/hr       → 0  (stable or falling — good sign)
    0–0.2 ft/hr     → 3  (slow rise)
    0.2–0.5 ft/hr   → 9  (moderate rise)
    0.5–1.0 ft/hr   → 15 (rapid rise — alert level)
    > 1.0 ft/hr     → 20 (dangerous rise — flash flood possible)

  Factor 3 — Short-term rain probability (0–15 pts)
    NWS 1-hour precipitation probability, used directly:
    Short bursts (< 1 hr) cause the most flash flooding on NJ roads.
    score = min(prob_1hr_pct × 0.15, 15)
    Examples: 20% → 3 pts | 60% → 9 pts | 100% → 15 pts

  Factor 4 — Sustained rain probability (0–10 pts)
    NWS 6-hour max precipitation probability:
    Sustained rain saturates soil and overwhelms drainage systems.
    score = min(prob_6hr_pct × 0.10, 10)
    Examples: 50% → 5 pts | 100% → 10 pts

  Factor 5 — FEMA flood zone (0–5 pts)
    Location falls within a known NJ FEMA high-risk flood zone: +5 pts flat.
    Source: 8 FEMA-designated bounding boxes across NJ.

  Seasonal multiplier (× 1.0 or × 1.15)
    NJ flood peaks during spring snowmelt (Mar–May) and hurricane season
    (Aug–Nov). During these months the base score is multiplied by 1.15.

  Final score = min(sum of factors × seasonal multiplier, 80)

RISK LEVELS (each band = 25% of the 0–80 scale):
   0–20  → Low       (normal conditions)
  21–40  → Moderate  (elevated, monitor)
  41–60  → High      (seek alternate route)
  61–80  → Severe    (do not proceed — Turn Around, Don't Drown)

EXAMPLE:
  Inputs:  gauge=11ft, rate=0.7ft/hr, prob_1hr=70%, prob_6hr=80%, flood_zone=True, month=April
  Factor1: 25 (gauge ≥ 10 ft)
  Factor2: 15 (rate 0.5–1.0)
  Factor3: 10.5 (70 × 0.15)
  Factor4: 8   (80 × 0.10)
  Factor5: 5   (flood zone)
  Base:    63.5
  × 1.15 (April): 73.0
  Score:   73 → CRITICAL
"""

# Known NJ FEMA high-risk flood zone bounding boxes
# (lat_min, lat_max, lng_min, lng_max, zone_name)
NJ_FLOOD_ZONES = [
    (40.60, 40.85, -74.25, -74.00, "Newark/Passaic River basin"),
    (40.10, 40.35, -74.10, -73.90, "Raritan River basin"),
    (39.90, 40.10, -74.30, -74.10, "Toms River area"),
    (40.45, 40.65, -74.55, -74.30, "Bound Brook / Somerset"),
    (40.85, 41.05, -74.20, -74.00, "Pompton Lakes / Wayne"),
    (39.35, 39.55, -74.65, -74.40, "Atlantic City coastal"),
    (40.70, 40.90, -74.10, -73.95, "Hackensack River"),
    (40.30, 40.50, -74.50, -74.25, "Millstone River"),
]

# NJ high-risk months: spring snowmelt + hurricane season
HIGH_RISK_MONTHS = {3, 4, 5, 8, 9, 10, 11}


def is_flood_zone(lat: float, lng: float) -> bool:
    for lat_min, lat_max, lng_min, lng_max, _ in NJ_FLOOD_ZONES:
        if lat_min <= lat <= lat_max and lng_min <= lng <= lng_max:
            return True
    return False


def _gauge_height_score(height_ft: float) -> float:
    """Factor 1: stream gauge height (0–30 pts)."""
    if height_ft >= 14:
        return 30
    elif height_ft >= 10:
        return 25
    elif height_ft >= 7:
        return 18
    elif height_ft >= 4:
        return 8
    return 0


def _gauge_rate_score(rate_ft_per_hr: float) -> float:
    """Factor 2: gauge rising rate (0–20 pts). Falling water = 0."""
    rate = max(0.0, rate_ft_per_hr)
    if rate > 1.0:
        return 20
    elif rate > 0.5:
        return 15
    elif rate > 0.2:
        return 9
    elif rate > 0.0:
        return 3
    return 0


def _precip_score(prob_1hr: float, prob_6hr: float) -> tuple[float, float]:
    """
    Factor 3+4: precipitation probability scores.
    prob_1hr and prob_6hr are percentages (0–100).
    """
    score_1hr = min(prob_1hr * 0.15, 15)   # max 15 pts at 100%
    score_6hr = min(prob_6hr * 0.10, 10)   # max 10 pts at 100%
    return score_1hr, score_6hr


def _risk_level(score: float) -> str:
    """
    Each band covers exactly 25% of the 0–80 scale so the label
    matches the numeric score intuitively.
      0–20  low       (≤ 25% of max)
      21–40 moderate  (26–50%)
      41–60 high      (51–75%)
      61–80 severe    (76–100%)
    """
    if score <= 20:
        return "low"
    elif score <= 40:
        return "moderate"
    elif score <= 60:
        return "high"
    return "severe"


def _recommendation(score: float, in_zone: bool) -> str:
    level = _risk_level(score)
    zone_note = " This area is a known NJ FEMA flood zone." if in_zone else ""
    if level == "low":
        return f"Score {score}/80 — Minimal flood risk.{zone_note} Safe to proceed with normal caution."
    elif level == "moderate":
        return f"Score {score}/80 — Some flood risk detected.{zone_note} Exercise caution and monitor conditions."
    elif level == "high":
        return f"Score {score}/80 — Elevated flood risk!{zone_note} Avoid low-lying roads and flood-prone areas."
    return f"Score {score}/80 — SEVERE flood risk!{zone_note} Do NOT proceed. Turn Around, Don't Drown."


def compute_risk_score(
    gauge_height_ft: float,
    gauge_rate_ft_per_hr: float,
    precip_prob_1hr_pct: float,
    precip_prob_6hr_pct: float,
    in_flood_zone: bool,
    month: int,
) -> float:
    """
    Compute flood risk score (0–80). Every point is traceable to a real factor.
    See module docstring for full breakdown.
    """
    score = 0.0
    score += _gauge_height_score(gauge_height_ft)
    score += _gauge_rate_score(gauge_rate_ft_per_hr)
    s1, s6 = _precip_score(precip_prob_1hr_pct, precip_prob_6hr_pct)
    score += s1 + s6
    if in_flood_zone:
        score += 5

    # Seasonal multiplier
    if month in HIGH_RISK_MONTHS:
        score *= 1.15

    return round(min(score, 80.0), 1)


class FloodMLModel:
    """
    Kept the class name for API compatibility.
    Internally uses transparent rule-based scoring — no ML model.
    """

    def assess_location(
        self,
        lat: float,
        lng: float,
        stream_gauge_height: float = 5.0,
        gauge_change_rate: float = 0.0,
        precip_prob_1hr: float = 0.0,
        precip_prob_6hr: float = 0.0,
        month: int = 6,
        hour: int = 12,
    ) -> dict:
        in_zone = is_flood_zone(lat, lng)
        score = compute_risk_score(
            gauge_height_ft=stream_gauge_height,
            gauge_rate_ft_per_hr=gauge_change_rate,
            precip_prob_1hr_pct=precip_prob_1hr,
            precip_prob_6hr_pct=precip_prob_6hr,
            in_flood_zone=in_zone,
            month=month,
        )
        return {
            "risk_score": score,
            "risk_level": _risk_level(score),
            "is_flood_zone": in_zone,
            "recommendation": _recommendation(score, in_zone),
        }


# Singleton — kept for import compatibility
flood_model = FloodMLModel()
